---
layout:     post
title:      "算法刷题记录"
subtitle:   ""
description: ""
date:       2024-09-05
author:     "MJJ"
published: true 
tags:
    - 算法
---

# 二叉树的层序遍历

## 题目

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**输入：** root = [3,9,20,null,null,15,7]
**输出：** [[3],[9,20],[15,7]]

**示例 2：**

**输入：** root = [1]
**输出：** [[1]]

**示例 3：**

**输入：** root = []
**输出：**[] 

## 思路

使用队列

## 代码实现

```C
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 定义树
struct TreeNode{
	int val;
	TreeNode *left;
	TreeNode *right;
};

void CreateTree(vector<TreeNode*> arr){
	int n = arr.size();
	for(int i=0;i<arr.size();i++){
		if(arr[i]==NULL){
			continue;
		}
		if(i*2+1 < n){
			arr[i]->left = arr[i*2+1];
		}
		if(i*2+2 < n){
			arr[i]->right = arr[i*2+2];
		}
	}
}

void Bfs(TreeNode* root, vector<vector<int>>& res){
	if(root==NULL) return;
	queue<TreeNode*> que;
	que.push(root);
	while(!que.empty()){
		vector<int> tmp;
		queue<TreeNode*> nodes;
		while(!que.empty()){
			TreeNode* node = que.front();
			que.pop();
			nodes.push(node);
			tmp.push_back(node->val);
		}
		while(!nodes.empty()){
			TreeNode* node = nodes.front();
			nodes.pop();
			if(node->left!=NULL) que.push(node->left);
			if(node->right!=NULL) que.push(node->right);
		}
		res.push_back(tmp);
	}
}

int main(){
	int n;
	cin >> n;
	vector<TreeNode*> arr;
	for(int i=0;i<n;i++){
		int val;
		cin >> val;
		if(val == -1){
			arr.push_back(NULL);
		}else{
			TreeNode* node = new TreeNode();
			node->val = val;
			node->left = NULL;
			node->right = NULL;
			arr.push_back(node);
		}
	}		
	vector<vector<int>> res;
	CreateTree(arr);
	Bfs(arr[0], res);
	return 0;
}
```